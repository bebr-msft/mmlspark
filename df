[1mdiff --git a/src/cntk/src/main/scala/com/microsoft/ml/spark/cntk/LIME.scala b/src/cntk/src/main/scala/com/microsoft/ml/spark/cntk/LIME.scala[m
[1mindex 51d681c..1d33e16 100644[m
[1m--- a/src/cntk/src/main/scala/com/microsoft/ml/spark/cntk/LIME.scala[m
[1m+++ b/src/cntk/src/main/scala/com/microsoft/ml/spark/cntk/LIME.scala[m
[36m@@ -74,17 +74,6 @@[m [mobject LIME extends ComplexParamsReadable[LIME] {[m
     sampler(t).take(n).toArray[m
   }[m
 [m
[31m-  def importanceMasking(threshold: Double = 0.0, greyscaleMask: Boolean = true): UserDefinedFunction =[m
[31m-    udf({ case (baseImage: Row, mask: DenseVector) =>[m
[31m-      val dv = if (!greyscaleMask) {[m
[31m-        new DenseVector(UnrollImage.unroll(baseImage).toArray[m
[31m-          .zip(mask.toArray)[m
[31m-          .map { case (e, m) => if (m > threshold) e else 0.0 })[m
[31m-      } else {[m
[31m-        throw new NotImplementedError("need to fill this in")[m
[31m-      }[m
[31m-      UnrollImage.roll(dv, baseImage)[m
[31m-    }, ImageSchema.columnSchema)[m
 [m
 }[m
 [m
[1mdiff --git a/src/cntk/src/main/scala/com/microsoft/ml/spark/cntk/Superpixel.java b/src/cntk/src/main/scala/com/microsoft/ml/spark/cntk/Superpixel.java[m
[1mindex 6be3466..f236c10 100644[m
[1m--- a/src/cntk/src/main/scala/com/microsoft/ml/spark/cntk/Superpixel.java[m
[1m+++ b/src/cntk/src/main/scala/com/microsoft/ml/spark/cntk/Superpixel.java[m
[36m@@ -1,4 +1,309 @@[m
 package com.microsoft.ml.spark.cntk;[m
 [m
[32m+[m[32mimport java.awt.Color;[m
[32m+[m[32mimport java.awt.image.BufferedImage;[m
[32m+[m[32mimport java.io.File;[m
[32m+[m[32mimport java.util.Arrays;[m
[32m+[m[32mimport java.util.Vector;[m
[32m+[m[32mimport javax.imageio.ImageIO;[m
[32m+[m
 public class Superpixel {[m
[32m+[m
[32m+[m[32m    // arrays to store values during process[m
[32m+[m[32m    double[] distances;[m
[32m+[m[32m    int[] labels;[m
[32m+[m[32m    int[] reds;[m
[32m+[m[32m    int[] greens;[m
[32m+[m[32m    int[] blues;[m
[32m+[m
[32m+[m[32m    Cluster[] clusters;[m
[32m+[m
[32m+[m[32m    // in case of instable clusters, max number of loops[m
[32m+[m[32m    int maxClusteringLoops = 50;[m
[32m+[m[32m    /**[m
[32m+[m[32m     * @param args[m
[32m+[m[32m     */[m
[32m+[m[32m    public static void main(String[] args) {[m
[32m+[m[32m        if (args.length!=4) {[m
[32m+[m[32m            System.out.println("Usage: java popscan.Superpixel"[m
[32m+[m[32m                    + " [source image filename]"[m
[32m+[m[32m                    + " [destination image filename]"[m
[32m+[m[32m                    + " [cell width S (1-255)]"[m
[32m+[m[32m                    + " [proximity modifier m (1-255)");[m
[32m+[m[32m            return;[m
[32m+[m[32m        }[m
[32m+[m[32m        // parse arguments[m
[32m+[m[32m        String src = args[0];[m
[32m+[m[32m        String dst = args[1];[m
[32m+[m[32m        double S = Integer.parseInt(args[2]);[m
[32m+[m[32m        double m = Double.parseDouble(args[3]);[m
[32m+[m[32m        BufferedImage img = loadImage(src);[m
[32m+[m[32m        Superpixel sp = new Superpixel();[m
[32m+[m[32m        BufferedImage dstImage = sp.calculate(img,S,m);[m
[32m+[m[32m        // save the resulting image[m
[32m+[m[32m        saveImage(dst, dstImage);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    public Superpixel() {    }[m
[32m+[m
[32m+[m[32m    public BufferedImage calculate(BufferedImage image,[m
[32m+[m[32m                                   double S, double m) {[m
[32m+[m[32m        int w = image.getWidth();[m
[32m+[m[32m        int h = image.getHeight();[m
[32m+[m[32m        BufferedImage result = new BufferedImage(w, h,[m
[32m+[m[32m                BufferedImage.TYPE_INT_RGB);[m
[32m+[m[32m        long start = System.currentTimeMillis();[m
[32m+[m
[32m+[m[32m        // get the image pixels[m
[32m+[m[32m        int[] pixels = image.getRGB(0, 0, w, h, null, 0, w);[m
[32m+[m
[32m+[m[32m        // create and fill lookup tables[m
[32m+[m[32m        distances = new double[w*h];[m
[32m+[m[32m        Arrays.fill(distances, Integer.MAX_VALUE);[m
[32m+[m[32m        labels = new int[w*h];[m
[32m+[m[32m        Arrays.fill(labels, -1);[m
[32m+[m[32m        // split rgb-values to own arrays[m
[32m+[m[32m        reds = new int[w*h];[m
[32m+[m[32m        greens = new int[w*h];[m
[32m+[m[32m        blues = new int[w*h];[m
[32m+[m[32m        for (int y=0;y<h;y++) {[m
[32m+[m[32m            for (int x=0;x<w;x++) {[m
[32m+[m[32m                int pos = x+y*w;[m
[32m+[m[32m                int color = pixels[pos];[m
[32m+[m[32m                reds[pos]   = color>>16&0x000000FF;[m
[32m+[m[32m                greens[pos] = color>> 8&0x000000FF;[m
[32m+[m[32m                blues[pos]  = color>> 0&0x000000FF;[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // create clusters[m
[32m+[m[32m        createClusters(image, S, m);[m
[32m+[m[32m        // loop until all clusters are stable![m
[32m+[m[32m        int loops = 0;[m
[32m+[m[32m        boolean pixelChangedCluster = true;[m
[32m+[m[32m        while (pixelChangedCluster&&loops<maxClusteringLoops) {[m
[32m+[m[32m            pixelChangedCluster = false;[m
[32m+[m[32m            loops++;[m
[32m+[m[32m            // for each cluster center C[m
[32m+[m[32m            for (int i=0;i<clusters.length;i++) {[m
[32m+[m[32m                Cluster c = clusters[i];[m
[32m+[m[32m                // for each pixel i in 2S region around[m
[32m+[m[32m                // cluster center[m
[32m+[m[32m                int xs = Math.max((int)(c.avg_x-S),0);[m
[32m+[m[32m                int ys = Math.max((int)(c.avg_y-S),0);[m
[32m+[m[32m                int xe = Math.min((int)(c.avg_x+S),w);[m
[32m+[m[32m                int ye = Math.min((int)(c.avg_y+S),h);[m
[32m+[m[32m                for (int y=ys;y<ye;y++) {[m
[32m+[m[32m                    for (int x=xs;x<xe;x++) {[m
[32m+[m[32m                        int pos = x+w*y;[m
[32m+[m[32m                        double D = c.distance(x, y, reds[pos],[m
[32m+[m[32m                                greens[pos],[m
[32m+[m[32m                                blues[pos],[m
[32m+[m[32m                                S, m, w, h);[m
[32m+[m[32m                        if ((D<distances[pos])&&(labels[pos]!=c.id)) {[m
[32m+[m[32m                            distances[pos]         = D;[m
[32m+[m[32m                            labels[pos]            = c.id;[m
[32m+[m[32m                            pixelChangedCluster = true;[m
[32m+[m[32m                        }[m
[32m+[m[32m                    } // end for x[m
[32m+[m[32m                } // end for y[m
[32m+[m[32m            } // end for clusters[m
[32m+[m[32m            // reset clusters[m
[32m+[m[32m            for (int index=0;index<clusters.length;index++) {[m
[32m+[m[32m                clusters[index].reset();[m
[32m+[m[32m            }[m
[32m+[m[32m            // add every pixel to cluster based on label[m
[32m+[m[32m            for (int y=0;y<h;y++) {[m
[32m+[m[32m                for (int x=0;x<w;x++) {[m
[32m+[m[32m                    int pos = x+y*w;[m
[32m+[m[32m                    clusters[labels[pos]].addPixel(x, y,[m
[32m+[m[32m                            reds[pos], greens[pos], blues[pos]);[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m
[32m+[m[32m            // calculate centers[m
[32m+[m[32m            for (int index=0;index<clusters.length;index++) {[m
[32m+[m[32m                clusters[index].calculateCenter();[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m
[32m+[m[32m        // Create output image with pixel edges[m
[32m+[m[32m        for (int y=1;y<h-1;y++) {[m
[32m+[m[32m            for (int x=1;x<w-1;x++) {[m
